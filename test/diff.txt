diff --git a/Makefile b/Makefile
index 9c15859..bb1b15a 100644
--- a/Makefile
+++ b/Makefile
@@ -12,7 +12,7 @@ BISON = /opt/homebrew/Cellar/bison/3.8.2/bin/bison
 CXXFLAGS += -std=c++17 \
 			-Wall \
 			-I/opt/homebrew/Cellar/flex/2.6.4_2/include \
-			-g
+			-g -O0
 LLVMFLAGS = -L$(LLVM_LIB) -lLLVM
 
 all: compiler.out
diff --git a/ast.cpp b/ast.cpp
index 5d2fa84..0b938fb 100644
--- a/ast.cpp
+++ b/ast.cpp
@@ -1,4 +1,5 @@
 #include "include/ast.h"
+#include <llvm/IR/Type.h>
 
 // TypeInfo 方法
 TypeInfo::TypeInfo()
@@ -44,6 +45,11 @@ llvm::Value* Program::codeGen(llvm::IRBuilder<>& builder, llvm::LLVMContext& con
         llvm::Function::Create(scanfType, llvm::Function::ExternalLinkage, "scanf", module);
     }
 
+    // 函数部分
+    for (auto& function: functions) {
+        function->codeGen(builder, context, module);
+    }
+
     // main函数
     llvm::FunctionType* funcType = llvm::FunctionType::get(llvm::Type::getInt32Ty(context), false);
     llvm::Function* mainFunc = llvm::Function::Create(funcType, llvm::Function::ExternalLinkage, "main", module);
@@ -80,8 +86,73 @@ void Func::print(int indent) const
 
 llvm::Value* Func::codeGen(llvm::IRBuilder<>& builder, llvm::LLVMContext& context, llvm::Module& module) const  
 {
-    std::cerr << "暂未实现" << std::endl;
-    return nullptr;
+    const std::string funcName= name->ident;
+
+    SymbolInfo* funcSymbol = scope->lookup(funcName);
+    if (!funcSymbol) {
+        std::cerr << "错误：函数符号 " << funcName << " 不存在" << std::endl;
+        return nullptr;
+    }
+
+    std::vector<llvm::Type*> argTypes;
+    for (const auto& typeInfo: funcSymbol->paramTypes) {
+        if (typeInfo.kind == SymbolKind::Array) {
+            // 数组退化成指针
+            llvm::Type* elementType = llvm::Type::getInt32Ty(context);
+            llvm::Type* arrayType = elementType;
+            for (int i = typeInfo.dims.size() - 1; i >= 0; i--) {
+                arrayType = llvm::ArrayType::get(arrayType, typeInfo.dims[i]);
+            }
+            argTypes.push_back(llvm::PointerType::get(arrayType, 0));
+        } else {
+            argTypes.push_back(llvm::Type::getInt32Ty(context));
+        }
+    }
+
+    llvm::FunctionType* funcType = llvm::FunctionType::get(
+        llvm::Type::getInt32Ty(context), argTypes, false
+    );
+
+    llvm::Function* function = llvm::Function::Create(
+        funcType, llvm::Function::ExternalLinkage, funcName, module
+    );
+
+    funcSymbol->value = function; // 更新函数指针
+
+    llvm::BasicBlock* entry = llvm::BasicBlock::Create(context, "entry", function);
+    builder.SetInsertPoint(entry);
+
+    int idx = 0;
+    for (auto& arg: function->args()) {
+        arg.setName(params->params[idx]->ident); // 设置形参名
+        SymbolInfo* argInfo = body_scope->lookupLocal(params->params[idx]->ident);
+        
+        if (argInfo->kind == SymbolKind::Array) {
+            // 数组：直接把传入的指针存储在 alloca 里
+            argInfo->addr = &arg;
+        } else {
+            llvm::AllocaInst* alloca = builder.CreateAlloca(arg.getType(), nullptr, arg.getName());
+            builder.CreateStore(&arg, alloca);
+            argInfo->addr = alloca;
+        }
+        argInfo->value = &arg;
+        idx++;
+    }
+
+    for (const auto& stmt: stmts->stmts) {
+        if (const auto* funcDef = dynamic_cast<const Func*>(stmt.get())) {
+            llvm::BasicBlock* beforeNested = builder.GetInsertBlock();
+            stmt->codeGen(builder, context, module);
+            builder.SetInsertPoint(beforeNested);
+        } else {
+            stmt->codeGen(builder, context, module);
+        }
+    }
+
+    llvm::Value* retVal = return_value->codeGen(builder, context, module);
+    builder.CreateRet(retVal);
+
+    return function;
 }
 
 // 语句列表节点
@@ -362,8 +433,26 @@ void FuncCallStmt::print(int indent) const
 
 llvm::Value* FuncCallStmt::codeGen(llvm::IRBuilder<>& builder, llvm::LLVMContext& context, llvm::Module& module) const  
 {
-    std::cerr << "暂未实现" << std::endl;
-    return nullptr;
+    const std::string& funcName = name->ident;
+
+    llvm::Function* calleeFunc = module.getFunction(funcName);
+    if (!calleeFunc) {
+        std::cerr << "错误：函数未定义：" << funcName << std::endl;
+        return nullptr;
+    }
+
+    std::vector<llvm::Value*> argsV;
+    if (args) {
+        for (const auto& argExpr: args->args) {
+            llvm::Value* argVal = argExpr->codeGen(builder, context, module);
+            if (!argVal) return nullptr;
+            argsV.push_back(argVal);
+        }
+    }
+
+    // 调用函数，不关心返回值
+    builder.CreateCall(calleeFunc, argsV);
+    return nullptr; // 作为语句，不返回值
 }
 
 // 输入语句节点
@@ -588,44 +677,50 @@ void ArraySubscriptExpr::print(int indent) const
     std::cout << "])" << std::endl;
 }
 
-llvm::Value* ArraySubscriptExpr::codeGen(llvm::IRBuilder<>& builder, llvm::LLVMContext& context, llvm::Module& module) const
-{
+llvm::Value* ArraySubscriptExpr::codeGen(llvm::IRBuilder<>& builder, llvm::LLVMContext& context, llvm::Module& module) const {
     SymbolInfo* symbol = scope->lookup(array->ident);
     if (!symbol) {
         std::cerr << "错误：数组 " << array->ident << " 未声明" << std::endl;
         return nullptr;
     }
 
-    llvm::AllocaInst* arrayPtr = symbol->addr;
+    llvm::Value* arrayAlloca = symbol->addr;
+    llvm::Value* arrayPtr = nullptr;
+
+    // 构造数组的完整类型：[d1 x [d2 x ... [dn x i32]]]
+    llvm::Type* elementType = llvm::Type::getInt32Ty(context);
+    for (int i = symbol->dimensions.size() - 1; i >= 0; --i) {
+        elementType = llvm::ArrayType::get(elementType, symbol->dimensions[i]);
+    }
+
+    if (symbol->isFuncParam) {
+        // 函数参数情况，形如：alloca ptr -> store ptr to array
+        arrayPtr = builder.CreateLoad(elementType->getPointerTo(), arrayAlloca, array->ident + "_loaded");
+    } else {
+        // 本地变量（alloca 的就是数组）
+        arrayPtr = arrayAlloca;
+    }
+
     if (!arrayPtr) {
         std::cerr << "错误：数组 " << array->ident << " 未分配空间" << std::endl;
         return nullptr;
     }
 
+    // 计算下标
     std::vector<llvm::Value*> indices;
-
     indices.push_back(llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0));
-
-    for (int i: subscript) {
+    for (int i : subscript) {
         indices.push_back(llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), i));
     }
 
-    llvm::Type* baseType = llvm::Type::getInt32Ty(context);
-
-    // 只构建未被索引的那部分维度
-    for (size_t i = symbol->dimensions.size(); i > 0; i--) {
-        baseType = llvm::ArrayType::get(baseType, symbol->dimensions[i - 1]);
-    }
-
     llvm::Value* gep = builder.CreateGEP(
-        baseType,
+        elementType,
         arrayPtr,
         indices,
         "array_elem"
     );
 
-    llvm::Type* valueType = llvm::Type::getInt32Ty(context);
-    return builder.CreateLoad(valueType, gep, "load_elem");
+    return builder.CreateLoad(llvm::Type::getInt32Ty(context), gep, "load_elem");
 }
 
 llvm::Value* ArraySubscriptExpr::getAddress(llvm::IRBuilder<>& builder, llvm::LLVMContext& context, llvm::Module& module) const {
@@ -635,25 +730,35 @@ llvm::Value* ArraySubscriptExpr::getAddress(llvm::IRBuilder<>& builder, llvm::LL
         return nullptr;
     }
 
-    llvm::AllocaInst* arrayPtr = symbol->addr;
+    llvm::Value* arrayAlloca = symbol->addr;
+    llvm::Value* arrayPtr = nullptr;
+
+    // 构造完整数组类型
+    llvm::Type* elementType = llvm::Type::getInt32Ty(context);
+    for (int i = symbol->dimensions.size() - 1; i >= 0; --i) {
+        elementType = llvm::ArrayType::get(elementType, symbol->dimensions[i]);
+    }
+
+    if (symbol->isFuncParam) {
+        arrayPtr = builder.CreateLoad(elementType->getPointerTo(), arrayAlloca, array->ident + "_loaded");
+    } else {
+        arrayPtr = arrayAlloca;
+    }
+
     if (!arrayPtr) {
         std::cerr << "错误：数组 " << array->ident << " 未分配空间" << std::endl;
         return nullptr;
     }
 
+    // 构造 GEP 索引
     std::vector<llvm::Value*> indices;
     indices.push_back(llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 0));
     for (int i : subscript) {
         indices.push_back(llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), i));
     }
 
-    llvm::Type* baseArrayType = llvm::Type::getInt32Ty(context);
-    for (auto it = symbol->dimensions.rbegin(); it != symbol->dimensions.rend(); it++) {
-        baseArrayType = llvm::ArrayType::get(baseArrayType, *it);
-    }
-
     llvm::Value* gep = builder.CreateGEP(
-        baseArrayType,
+        elementType,
         arrayPtr,
         indices,
         "array_elem"
@@ -703,6 +808,8 @@ llvm::Value* IdentExpr::codeGen(llvm::IRBuilder<>& builder, llvm::LLVMContext& c
     if (symbol->kind == SymbolKind::Int) {
         llvm::Type* valueType = llvm::Type::getInt32Ty(context);
         return builder.CreateLoad(valueType, symbol->addr, ident);
+    } else if (symbol->kind == SymbolKind::Array) {
+        return symbol->addr;
     }
 
     std::cerr << "错误：不支持返回的标识符 " << ident << std::endl;
@@ -727,8 +834,24 @@ void FuncCallExpr::print(int indent) const
 
 llvm::Value* FuncCallExpr::codeGen(llvm::IRBuilder<>& builder, llvm::LLVMContext& context, llvm::Module& module) const  
 {
-    std::cerr << "暂未实现" << std::endl;
-    return nullptr;
+    const std::string& funcName = name->ident;
+
+    llvm::Function* calleeFunc = module.getFunction(funcName);
+    if (!calleeFunc) {
+        std::cerr << "错误：函数未定义：" << funcName << std::endl;
+        return nullptr;
+    }
+
+    std::vector<llvm::Value*> argsV;
+    if (args) {
+        for (const auto& argExpr: args->args) {
+            llvm::Value* argVal = argExpr->codeGen(builder, context, module);
+            if (!argVal) return nullptr;
+            argsV.push_back(argVal);
+        }
+    }
+
+    return builder.CreateCall(calleeFunc, argsV, funcName + "_call");
 }
 
 // 参数列表节点
diff --git a/include/ast.h b/include/ast.h
index 4a1b9d1..f56a626 100644
--- a/include/ast.h
+++ b/include/ast.h
@@ -81,6 +81,7 @@ struct Func: public Stmt
     std::unique_ptr<ParamList> params; // Nullable
     std::unique_ptr<StmtList> stmts;
     std::unique_ptr<Expr> return_value;
+    Scope* body_scope;
 
     Func(std::unique_ptr<IdentExpr> name, std::unique_ptr<ParamList> params, std::unique_ptr<StmtList> stmts, std::unique_ptr<Expr> return_value);
 
diff --git a/include/symbol.h b/include/symbol.h
index fc47d5f..dbaa628 100644
--- a/include/symbol.h
+++ b/include/symbol.h
@@ -27,7 +27,8 @@ struct SymbolInfo
     std::vector<int> dimensions;        // 展平后的数组维度信息
     std::vector<TypeInfo> paramTypes;   // 函数参数类型信息
     llvm::Value* value = nullptr;       // LLVM变量或函数指针
-    llvm::AllocaInst* addr = nullptr;   // LLVM变量栈地址
+    llvm::Value* addr = nullptr;        // LLVM变量栈地址
+    bool isFuncParam = false;           // 是否为函数参数(影响数组访问)
     
     SymbolInfo(SymbolKind kind, const std::string& name);
     SymbolInfo(const std::string& name, const TypeInfo& type);
diff --git a/semanticAnalysis.cpp b/semanticAnalysis.cpp
index b19da52..7bd6567 100644
--- a/semanticAnalysis.cpp
+++ b/semanticAnalysis.cpp
@@ -45,7 +45,8 @@ void SemanticAnalyzer::analyzeProgram(Program& program)
 void SemanticAnalyzer::analyzeFunc(Func& func)
 {
     func.scope = currentScope;
-    enterScope();    
+    enterScope();
+    func.body_scope = currentScope;
     if (func.params) {
         for (const auto& param: func.params->params) {
             // TODO: 这里可能有求值存入value的需求
diff --git a/test/test3 b/test/test3
index a33ebfe..7a092c9 100755
Binary files a/test/test3 and b/test/test3 differ
diff --git a/test/test3.l25 b/test/test3.l25
index 3815d03..17637fa 100644
--- a/test/test3.l25
+++ b/test/test3.l25
@@ -1,17 +1,16 @@
 program test {
+    func tt(a, d:[3,4,5]) {
+        func aaa() {
+            let a = 1;
+            return 1;
+        };
+        d[1,2,3] = 31241;
+        return d[1,2,3] + aaa();
+    }
     main {
         let a;
         let b: [3,4,5];
-        input(a);
-        b[1,2,3] = 1;
-        while (a < 100) {
-            while (a < 50) {
-                a = a + 10;
-            };
-            a = a + 1;
-            output(a);
-        };
+        tt(1, b);
         output(b[1,2,3]);
-        output(5*6+3, 3*(4+6*(8-5)));
     }
 }
\ No newline at end of file
diff --git a/test/test3.ll b/test/test3.ll
index ab7dfe6..1b59150 100644
--- a/test/test3.ll
+++ b/test/test3.ll
@@ -1,56 +1,39 @@
-@0 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
-@1 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
-@2 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
-@3 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
+@0 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
 
 declare i32 @printf(ptr, ...)
 
 declare i32 @scanf(ptr, ...)
 
+define i32 @tt(i32 %a, ptr %d) {
+entry:
+  %a1 = alloca i32, align 4
+  store i32 %a, ptr %a1, align 4
+  %array_elem = getelementptr [3 x [4 x [5 x i32]]], ptr %d, i32 0, i32 1, i32 2, i32 3
+  store i32 31241, ptr %array_elem, align 4
+  %array_elem2 = getelementptr [3 x [4 x [5 x i32]]], ptr %d, i32 0, i32 1, i32 2, i32 3
+  %load_elem = load i32, ptr %array_elem2, align 4
+  %aaa_call = call i32 @aaa()
+  %addtmp = add i32 %load_elem, %aaa_call
+  ret i32 %addtmp
+}
+
+define i32 @aaa() {
+entry:
+  %a = alloca i32, align 4
+  store i32 1, ptr %a, align 4
+  ret i32 1
+}
+
 define i32 @main() {
 entry:
   %a = alloca i32, align 4
   %b = alloca [3 x [4 x [5 x i32]]], align 4
   call void @llvm.memset.p0.i64(ptr %b, i8 0, i64 240, i1 false)
-  %0 = call i32 (ptr, ...) @scanf(ptr @0, ptr %a)
+  %0 = call i32 @tt(i32 1, ptr %b)
   %array_elem = getelementptr [3 x [4 x [5 x i32]]], ptr %b, i32 0, i32 1, i32 2, i32 3
-  store i32 1, ptr %array_elem, align 4
-  br label %while.cond
-
-while.cond:                                       ; preds = %while.after4, %entry
-  %a1 = load i32, ptr %a, align 4
-  %cmplt = icmp slt i32 %a1, 100
-  br i1 %cmplt, label %while.body, label %while.after
-
-while.body:                                       ; preds = %while.cond
-  br label %while.cond2
-
-while.after:                                      ; preds = %while.cond
-  %array_elem11 = getelementptr [3 x [4 x [5 x i32]]], ptr %b, i32 0, i32 1, i32 2, i32 3
-  %load_elem = load i32, ptr %array_elem11, align 4
-  %1 = call i32 (ptr, ...) @printf(ptr @2, i32 %load_elem)
-  %2 = call i32 (ptr, ...) @printf(ptr @3, i32 33)
-  %3 = call i32 (ptr, ...) @printf(ptr @3, i32 66)
+  %load_elem = load i32, ptr %array_elem, align 4
+  %1 = call i32 (ptr, ...) @printf(ptr @0, i32 %load_elem)
   ret i32 0
-
-while.cond2:                                      ; preds = %while.body3, %while.body
-  %a5 = load i32, ptr %a, align 4
-  %cmplt6 = icmp slt i32 %a5, 50
-  br i1 %cmplt6, label %while.body3, label %while.after4
-
-while.body3:                                      ; preds = %while.cond2
-  %a7 = load i32, ptr %a, align 4
-  %addtmp = add i32 %a7, 10
-  store i32 %addtmp, ptr %a, align 4
-  br label %while.cond2
-
-while.after4:                                     ; preds = %while.cond2
-  %a8 = load i32, ptr %a, align 4
-  %addtmp9 = add i32 %a8, 1
-  store i32 %addtmp9, ptr %a, align 4
-  %a10 = load i32, ptr %a, align 4
-  %4 = call i32 (ptr, ...) @printf(ptr @1, i32 %a10)
-  br label %while.cond
 }
 
 ; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
